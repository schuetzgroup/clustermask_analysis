function varargout = clustermask_recordROI(varargin)
%% ------------------------------------------------------------------------
% clustermask_recordROI
% -------------------------------------------------------------------------
% author: Andreas Arnold
% -------------------------------------------------------------------------
% syntax: [cellroi_xy, use] = clustermask_recordROI(roi,gridsize,filename,
%                                                       pathname,pixelsize)
% -------------------------------------------------------------------------
%
% CLUSTERMASK_RECORDROI plots all localizations from superresolution images
% generated by the ImageJ-Plugin ThunderSTORM in *.csv - format
% (xy-localization files). Alternative input formats are also implemented.
% The function also allows for skipping unreliable files entirely
% (e.g. if the image quality is bad).
%
% INPUT:  1) roi        ... refers to the dimensions of the recorded image
%                           in pixels (e.g. roi=128 for a 128x128px image);
%         2) gridsize   ... number of pixel used for binary mask (e.g.
%                           grid size 1024 for a 1024x1024 pixel mask);
%         3) filename   ... name of *.csv file;
%         4) pathname   ... folder where file is saved;
%         5) pixelsize  ... pixel size of camera pixel (in nm/px);
% 
% OUTPUT: 1) cellroi_xy ... array containing coordinates of polygon ROI to
%                           process only localizations on the cell;
%         2) use        ... logical array that encodes which files were
%                           skipped;


%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
% begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
    'gui_Singleton',  gui_Singleton, ...
    'gui_OpeningFcn', @clustermask_recordROI_OpeningFcn, ...
    'gui_OutputFcn',  @clustermask_recordROI_OutputFcn, ...
    'gui_LayoutFcn',  [] , ...
    'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end
 
if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% end initialization code - DO NOT EDIT
%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 
 
 
%%%-------------------------------------------------%%%
%%%--- OPENING FUNCTION OF clustermask_recordROI ---%%%
%%%-------------------------------------------------%%%

% --- executes just before clustermask_recordROI is made visible.
function clustermask_recordROI_OpeningFcn(hObject, eventdata, handles,...
    varargin)
% choose default command line output for clustermask_recordROI
handles.output = hObject;
 
% read input from varargin
handles.roi=cell2mat(varargin(1));
handles.gridsize=cell2mat(varargin(2));
handles.file=varargin{3};
path=varargin{4};
pixelsize=varargin{5};
 
% load data
if strcmp(handles.file(end-3:end),'.trc')
    temp = load(fullfile(path,handles.file),'-ascii');
    pos = temp(:,3:4);
elseif strcmp(handles.file(1:3),'bin') && strcmp...
        (handles.file(end-3:end),'.mat')
    temp = load(fullfile(path,handles.file));
    temp = temp.bin;
    pos(:,1) = temp(:,1); pos(:,2) = temp(:,2);
elseif strcmp(handles.file(end-3:end),'.mat')
    temp = load(fullfile(path,handles.file));
    temp = temp.MT;
    pos(:,1) = temp(:,1); pos(:,2) = temp(:,2);
elseif strcmp(handles.file(end-3:end),'.csv')
    tmp = csvread(fullfile(path,handles.file),1,0);
    pos(:,1) = tmp(:,2)/pixelsize; pos(:,2) = tmp(:,3)/pixelsize;
end
handles.pos=pos;
 
% plot data in correct size (adjusted to virtual number of pixel)
axes(handles.datafigure)
plot_data(pos,handles.roi);
% show filename
title(handles.file,'Interpreter','none')
 
% create handles.recording (prevents multiple  button press on "Set ROI")
handles.recording=false;
handles.recordDONE=false;
 
% update handles structure
guidata(hObject, handles);
 
% UIWAIT makes clustermask_recordROI wait for user response (see UIRESUME)
uiwait(handles.figure_recordROI);
 

%%%---------------------------------------------%%%
%%%---CALLBACKS OF GUI clustermask_recordROI ---%%%
%%%---------------------------------------------%%%

% --- outputs from this function are returned to the command line
function varargout = clustermask_recordROI_OutputFcn(hObject,...
    eventdata, handles)
% get default command line output from handles structure
varargout{1} = handles.cellroi_xy;
varargout{2} = handles.use;
% delete figure after closing
delete(handles.figure_recordROI);



% --- executes on button press in OK.
% --> transfers drawn polygon ROI to output and closes figure
function OK_Callback(hObject, eventdata, handles)
 
handles.use=true;
% update handles structure
guidata(hObject, handles);
 
% close clustermask_recordROI
if ~handles.recording && handles.recordDONE
    close(handles.figure_recordROI);
elseif ~handles.recording && ~handles.recordDONE
    handles.cellroi_xy=[];
    %Update handles structure
    guidata(hObject, handles);
    close(handles.figure_recordROI);
end
 
 
% --- executes on button press in skip.
% --> no polygon ROI is transferred to output
%     instead handles.use is set to 0, i.e. this file will be skipped in
%     further analysis
function skip_Callback(hObject, eventdata, handles)
% ask if this file should really be skipped
answer=clustermask_recordROI_skipcell;
if strcmp(answer,'Yes')
    handles.cellroi_xy = [];
    handles.use=false;
    guidata(hObject, handles);
    
    close(handles.figure_recordROI);
end
 
 
% --- executes on button press in setROI.
% --> draws polygon ROI
function setROI_Callback(hObject, eventdata, handles)
 
% make sure no recording process has been started so far
if ~handles.recording
    handles.recording = true;
    handles.recordDONE = false;
    guidata(hObject, handles);
    
    % plot data
    handles.datafigure = plot_data(handles.pos,handles.roi);
    
    % draw ROI
    cellroi = impoly;
    xy = getPosition(cellroi);
    handles.cellroi_xy = xy;
    
    handles.recording = false;
    handles.recordDONE = true;
    
    % update handles structure
    guidata(hObject, handles);
    % keep GUI waiting
    uiwait(handles.figure_recordROI);
end
 
 
% --- executes when user attempts to close figure_recordROI.
% --> this function closes the GUI
function figure_recordROI_CloseRequestFcn(hObject, eventdata, handles)
% Hint: delete(hObject) closes the datafigure
if isequal(get(hObject, 'waitstatus'), 'waiting')
    % the GUI is still in UIWAIT, us UIRESUME
    uiresume(hObject);
else
    % the GUI is no longer waiting, just close it
    delete(hObject);
end
 

%%%------------------------------------------------------%%%
%%%---SUPPORT FUNCTIONS FOR GUI clustermask_recordROI ---%%%
%%%------------------------------------------------------%%%
 
function p = plot_data(data,roi)
cla;
% plot localizations
hold on;
axis([0, roi, 0, roi]);
p = plot(data(:, 1),data(: , 2), 'r.','Markersize',4);
hold off;
 
 
%%%--------------------------------%%%
%%%--- EMPTY CALLBACK FUNCTIONS ---%%%
%%%--------------------------------%%%
 
% --- Executes when figure_recordROI is resized.
function figure_recordROI_ResizeFcn(hObject, eventdata, handles)


